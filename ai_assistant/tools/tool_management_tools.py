# ai_assistant/tools/tool_management_tools.py
import asyncio
import os
import re
import importlib
import sys
from typing import Dict, Any

from ai_assistant.code_services.service import CodeService
from ai_assistant.llm_interface import ollama_client as default_llm_provider
from ai_assistant.core import self_modification as default_self_modification_service
from ai_assistant.core.fs_utils import write_to_file
from ai_assistant.tools.tool_system import tool_system_instance
from ai_assistant.core.reflection import global_reflection_log
from ai_assistant.config import is_debug_mode
from ai_assistant.utils.display_utils import CLIColors, color_text # For potential debug prints


async def generate_and_register_tool_backend(tool_description: str) -> Dict[str, Any]:
    """
    Handles the backend process of generating code via CodeService,
    saving it, and registering it as a tool. This version is less interactive
    than the CLI's _handle_code_generation_and_registration.
    """
    if is_debug_mode():
        print(color_text(f"[DEBUG TOOL_MGMT] Received request to generate tool: {tool_description}", CLIColors.DEBUG_MESSAGE))

    code_service = CodeService(
        llm_provider=default_llm_provider,
        self_modification_service=default_self_modification_service
    )
    generation_result = await code_service.generate_code(
        context="NEW_TOOL",
        prompt_or_description=tool_description,
        target_path=None  # CodeService might handle path suggestion or use defaults
    )

    if is_debug_mode():
        print(color_text(f"[DEBUG TOOL_MGMT] CodeService generation result: {generation_result}", CLIColors.DEBUG_MESSAGE))

    if generation_result.get("status") != "SUCCESS_CODE_GENERATED":
        error_msg = generation_result.get("error", "CodeService failed to generate code or parse metadata.")
        global_reflection_log.log_execution(
            goal_description=f"Automated tool generation failed (generation_error): {tool_description}",
            plan=[{'action_type': 'AUTO_TOOL_GEN_FAIL', 'description': tool_description}],
            execution_results=[f"CodeService failed. Status: {generation_result.get('status')}, Error: {error_msg}"],
            overall_success=False
        )
        return {"status": "error", "message": f"Tool generation failed: {error_msg}"}

    cleaned_code = generation_result.get("code_string")
    parsed_metadata = generation_result.get("metadata")

    if not cleaned_code or not parsed_metadata:
        global_reflection_log.log_execution(
            goal_description=f"Automated tool generation failed (missing_data): {tool_description}",
            plan=[{'action_type': 'AUTO_TOOL_GEN_FAIL', 'description': tool_description}],
            execution_results=["CodeService reported success but returned incomplete data (missing code/metadata)."],
            overall_success=False
        )
        return {"status": "error", "message": "Tool generation succeeded but metadata or code is missing."}

    # Simplified saving and registration using metadata or defaults
    function_name = parsed_metadata.get("suggested_function_name", "generated_tool_func")
    tool_name_from_meta = parsed_metadata.get("suggested_tool_name", "newly_generated_tool")
    description_for_reg = parsed_metadata.get("suggested_description", tool_description)

    safe_tool_name_base = re.sub(r'[^\w_]', '', tool_name_from_meta.lower())
    if not safe_tool_name_base: safe_tool_name_base = "custom_generated_tool"
    filename = f"{safe_tool_name_base}.py"
    filepath_to_save = os.path.join("ai_assistant", "custom_tools", filename)
    module_path_for_registration = f"ai_assistant.custom_tools.{safe_tool_name_base}"

    if not write_to_file(filepath_to_save, cleaned_code):
        return {"status": "error", "message": f"Failed to save generated code to {filepath_to_save}."}

    try:
        if module_path_for_registration in sys.modules:
            importlib.reload(sys.modules[module_path_for_registration])
        imported_module = importlib.import_module(module_path_for_registration)
        function_object = getattr(imported_module, function_name)
        tool_system_instance.register_tool(
            tool_name=tool_name_from_meta,
            description=description_for_reg,
            module_path=module_path_for_registration,
            function_name_in_module=function_name,
            tool_type="dynamic_generated", # Mark as generated by this process
            func_callable=function_object
        )
        return {"status": "success", "message": f"Tool '{tool_name_from_meta}' generated, saved to '{filepath_to_save}', and registered successfully."}
    except Exception as e:
        return {"status": "error", "message": f"Tool '{tool_name_from_meta}' generated and saved, but registration failed: {e}"}