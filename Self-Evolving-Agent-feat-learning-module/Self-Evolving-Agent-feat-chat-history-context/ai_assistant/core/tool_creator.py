# ai_assistant/core/tool_creator.py
import os
import logging
import ast # For basic code validation
from typing import List, Dict, Any
from ai_assistant.config import get_data_dir # To store tools in a sub-directory of data_dir

logger = logging.getLogger(__name__)

# Define a subdirectory within the main data_dir for generated tools
GENERATED_TOOLS_SUBDIR = "generated_tools"

def get_generated_tools_dir() -> str:
    """Returns the absolute path to the directory for storing generated tools."""
    base_data_dir = get_data_dir()
    tools_dir = os.path.join(base_data_dir, GENERATED_TOOLS_SUBDIR)
    os.makedirs(tools_dir, exist_ok=True)
    return tools_dir

def _is_valid_python_syntax(code_string: str, is_function_body: bool = False) -> bool:
    """Basic check if the string is valid Python syntax."""
    try:
        if is_function_body:
            # Wrap in a dummy function for syntax checking of a body
            ast.parse(f"def temp_func():\n{code_string}")
        else:
            ast.parse(code_string)
        return True
    except SyntaxError:
        return False

def create_new_tool(
    tool_name: str,
    tool_description: str,
    parameters: List[Dict[str, str]], # e.g., [{"name": "arg1", "type": "str", "description": "First argument"}]
    function_body_code: str,
    return_type: str = "Any", # Default return type
    required_imports: List[str] = None, # e.g., ["import os", "from typing import List"]
    return_description: str = "(Description of return value, ideally AI-provided or refined later)" # New parameter
) -> str:
    """
    Creates a new Python tool file based on AI-provided specifications.

    Args:
        tool_name (str): Desired name for the tool (e.g., 'my_file_writer').
                         This will be the function name and filename (my_file_writer.py).
        tool_description (str): Description of what the tool does.
        parameters (List[Dict[str, str]]): List of dictionaries, each describing a parameter.
                                           Each dict: {'name': str, 'type': str, 'description': str}.
        function_body_code (str): Python code string for the body of the tool's main function.
                                  Should use 'return' for results.
        return_type (str): Python type hint for the return value (e.g., "str", "bool").
        required_imports (List[str]): List of import statements (e.g., "import json").
        return_description (str): Description of what the function returns, for the docstring.

    Returns:
        str: Message indicating success (including file path) or failure.
    """
    logger.info(f"Attempting to create new tool: {tool_name}")

    if not tool_name.isidentifier():
        msg = f"Error: Tool name '{tool_name}' is not a valid Python identifier."
        logger.error(msg)
        return msg

    if not _is_valid_python_syntax(function_body_code, is_function_body=True):
        msg = f"Error: Provided function_body_code for tool '{tool_name}' has a syntax error."
        logger.error(msg)
        return msg

    param_defs = []
    param_docstrings = []
    for p in parameters:
        if not all(k in p for k in ["name", "type", "description"]):
            msg = f"Error: Invalid param structure for '{p.get('name', 'unknown')}'. Must include 'name', 'type', 'description'."
            logger.error(msg)
            return msg
        if not p["name"].isidentifier():
            msg = f"Error: Parameter name '{p['name']}' is not a valid Python identifier."
            logger.error(msg)
            return msg
        param_defs.append(f"{p['name']}: {p['type']}")
        param_docstrings.append(f"            {p['name']} ({p['type']}): {p['description']}")

    param_defs_str = ", ".join(param_defs)
    param_docstrings_str = "\n".join(param_docstrings)
    imports_str = "\n".join(required_imports) if required_imports else ""
    indented_function_body = "\n".join(["    " + line for line in function_body_code.splitlines()])

    file_content = f"""\
# Tool: {tool_name}
# Automatically generated by AI Assistant's create_new_tool.
{imports_str}
from typing import Any, List, Dict # Common typing imports

TOOL_METADATA = {{
    "name": "{tool_name}",
    "description": "{tool_description}",
    "parameters": {parameters!r},
    "return_type": "{return_type}"
}}

def {tool_name}({param_defs_str}) -> {return_type}:
    \"\"\"
    {tool_description}

    Args:
{param_docstrings_str}

    Returns:
        {return_type}: {return_description}
    \"\"\"
    # AI-provided function body starts here
{indented_function_body}
    # AI-provided function body ends here

if __name__ == '__main__':
    print(f"Testing tool: {tool_name}")
    # This is a placeholder for testing.
    # Implement example calls based on the tool's parameters.
    print("To test, provide sample arguments if the tool requires them.")
"""

    tools_dir = get_generated_tools_dir()
    file_name = f"{tool_name}.py"
    file_path = os.path.join(tools_dir, file_name)

    if os.path.exists(file_path):
        msg = f"Error: Tool file '{file_path}' already exists. Overwriting not allowed by default."
        logger.warning(msg)
        return msg

    try:
        with open(file_path, "w", encoding="utf-8") as f:
            f.write(file_content)
        logger.info(f"Successfully created tool '{tool_name}' at: {file_path}")
        return f"Successfully created tool '{tool_name}'. Saved to: {file_path}. Manual activation/registration may be required."
    except IOError as e:
        msg = f"Error: Could not write tool file to '{file_path}'. IO Error: {e}"
        logger.error(msg)
        return msg
    except Exception as e:
        msg = f"Error: An unexpected error occurred while creating tool '{tool_name}'. Error: {e}"
        logger.error(msg, exc_info=True)
        return msg

# Conceptual schema for how the AI would understand this 'create_new_tool' function as a tool:
CREATE_NEW_TOOL_SCHEMA = {
    "name": "create_new_tool",
    "description": "Creates a new Python tool file. Provide tool name, description, parameters, Python code for its function body, return type, and required imports. The tool is saved but may need manual activation.",
    "parameters": [
        {"name": "tool_name", "type": "str", "description": "Name of the tool (Python identifier, e.g., 'file_reader')."},
        {"name": "tool_description", "type": "str", "description": "What the tool does."},
        {"name": "parameters", "type": "list", "description": "List of dicts for parameters: [{'name': 'param_name', 'type': 'param_type', 'description': 'param_desc'}]."},
        {"name": "function_body_code", "type": "str", "description": "Python code for the function body. E.g., 'return path.exists()'."},
        {"name": "return_type", "type": "str", "description": "Return type hint (e.g., 'bool', 'str'). Defaults to 'Any'."},
        {"name": "required_imports", "type": "list", "description": "Optional list of import strings. E.g., ['import os.path']."},
        {"name": "return_description", "type": "str", "description": "Optional description of the return value for the docstring."}
    ]
}